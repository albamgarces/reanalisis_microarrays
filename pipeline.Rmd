---
title: "Pipeline PEC1"
author: "Alba Moya Garcés"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output: 
  pdf_document:
    toc: yes
nocite: |
  @*
bibliography: biblio_PEC1.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=TRUE, warning=FALSE, message=FALSE, fig_caption = TRUE)
```



1. Identificar que grupos hay y a qué grupo pertenece cada muestra.
2. Control de calidad de los datos crudos
3. Normalización
4. [Control de calidad de los datos normalizados] (opcional)
5. Filtraje no específico [opcional]
6. Identificación de genes diferencialmente expresados
7. Anotación de los resultados: 
8. Comparación entre distintas comparaciones (si hay más de una comparación, ver que genes han sido seleccionados en más de una comparación)
9. Análisis de significación biológica (“Gene Enrichment Analysis”)

Estudio elegido:

**Gene expression in mitotic tissues of Drosophila larvae without centrosomes or too many centrosomes**


La expresión genética de las líneas mutantes se compararon con ambas líneas salvajes de control. 



- Tipo de microarrays que utilizan: se hibridaron con arrays *Affymetrix Drosophila Genome 2.0*

- Número de muestras y grupos que contiene el estudio: 

Se diseccionaron tejidos mitóticos (cerebrales y de los discos imaginales) de 10 larvas de *Drosophila* en estadío 3:    

| ausencia de centrosomas | | exceso de centrosomas | tipo salvaje | |
| DSas-4 | DSas-6 | SakOE |  WT w67 | WT OregonR|  
| | | | | |    


Se extrajo el ARN de **tres réplicas** por cada línea (15 muestras en total)

|GSM864362 |	brains and imaginal discs from D-Sas4 mutant 3rd instar Drosophila larvae | biological replicate 1|
|GSM864363 |	brains and imaginal discs from D-Sas4 mutant 3rd instar Drosophila larvae | biological replicate 2|

|GSM864364 	brains and imaginal discs from D-Sas4 mutant 3rd instar Drosophila larvae, biological replicate 3|
|GSM864365 	brains and imaginal discs from D-Ssas6 mutant 3rd instar Drosophila larvae, biological replicate 1
GSM864366 	brains and imaginal discs from D-Ssas6 mutant 3rd instar Drosophila larvae, biological replicate 2
GSM864367 	brains and imaginal discs from D-Ssas6 mutant 3rd instar Drosophila larvae, biological replicate 3
GSM864368 	brains and imaginal discs from Sak overexpressing 3rd instar Drosophila larvae, biological replicate 1
GSM864369 	brains and imaginal discs from Sak overexpressing 3rd instar Drosophila larvae, biological replicate 2
GSM864370 	brains and imaginal discs from Sak overexpressing 3rd instar Drosophila larvae, biological replicate 3
GSM864371 	brains and imaginal discs from w67 wild type 3rd instar Drosophila larvae, biological replicate 1
GSM864372 	brains and imaginal discs from w67 wild type 3rd instar Drosophila larvae, biological replicate 2
GSM864373 	brains and imaginal discs from w67 wild type 3rd instar Drosophila larvae, biological replicate 3
GSM864374 	brains and imaginal discs from OregonR wild type 3rd instar Drosophila larvae, biological replicate 1
GSM864375 	brains and imaginal discs from OregonR wild type 3rd instar Drosophila larvae, biological replicate 2
GSM864376 	brains and imaginal discs from OregonR wild type 3rd instar Drosophila larvae, biological replicate 3

- Que pregunta principal persigue responder: Evaluar cómo la pérdida o amplificación de los centrosomas puede afectar la fisiología celular al perfilarse el transcriptoma global cerebral y de los [discos imaginales](https://es.wikipedia.org/wiki/Disco_imaginal) de las larvas de *Drosophila*.
- Enlace a los datos y/o al artículo artículo: https://bio.biologists.org/content/1/10/983.short
- Comentarios adicionales

# Methods

## Preparación del área de trabajo:

Para llevar a cabo un análisis de microarrays, el analista debe gestionar una gran cantidad de archivos entre aquesllos que ocupan los datos originales y los generados durante su análisis. Es por ello que siempre se debería comenzar creando als carpetas necesarias para simplificar la ruta de trabajo. Se recomienda generar una **carpeta principal** con el nombre de nuestro proyecto en cuyo interior alojaremos una carpeta con los archivos de **datos** y otra con los **resultados** generados del análisis

Estas carpetas las genereamos rápidamente desde el explorador de archivos o la consola de cualquiera de los sistemas operativos usuales. Desde R también podemos generar estas subcarpetas mediante el siguiente código:


```{r Carpetas, eval=FALSE}
setwd(".")
dir.create("data")
dir.create("results")
```

El código completo para desarrollar este análisis, o cualquier otro a partir de su adaptación, puede descargarse del siguiente repositorio de *GitHub*:

[https://github.com/albamgarces/reanalisis_microarrays.git](https://github.com/albamgarces/reanalisis_microarrays.git). 


##Instalación de paquetes en R

Se necesitarán paquetes adicionales a los incluidos en la intalación básica de R para poder llevar a cabo el análisis. Estos paquetes pueden descargarse tanto del repositorio CRAN para los paquetes típicos de R o directamente de Bioconductor para las funciones del mismo.

```{r BioconductorInstalling}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#      install.packages("BiocManager")
# BiocManager::install()
```

A continuación se muestran los paquetes necesarios fara este estudio que requieren instalación:

```{r instalacionPaquetes}
# # UNCOMMENT IF INSTALL REQUIRES
## install.packages("knitr")
# install.packages("colorspace")
##install.packages("cluster")
## install.packages("gplots")
## install.packages("ggplot2")
## install.packages("ggrepel")
# install.packages("htmlTable")
# install.packages("prettydoc")
# install.packages("devtools")
# install.packages("BiocManager")
# BiocManager::install("oligo")
# BiocManager::install("pd.mogene.2.1.st")
## BiocManager::install("arrayQualityMetrics")
# BiocManager::install("pvca")
# # NOT NEEDED UNTIL ANALYSES ARE PERFORMED
# BiocManager::install("limma")
# BiocManager::install("genefilter")
# BiocManager::install("mogene21sttranscriptcluster.db")
# BiocManager::install("annotate")
# BiocManager::install("org.Mm.eg.db")
# BiocManager::install("ReactomePA")
# BiocManager::install("reactome.db")
## BiocManager::install("pacman")
```


```{r requirePaquetes}
# require(knitr)
# require(kableExtra)
require(ggdendro)
require(arrayQualityMetrics)
require(factoextra)
require(ggplot2)
require(ggrepel)
require(cluster)
```


##Descarga de los datos

En lugar de descargar los archivos .CEL y construir manualmente el archivo "targets", se utilizará el paquete `geoQuery` para generar de forma automática el objeto ExpressionSet necesario para el análisis. De esta forma se evitan posibles errores de transcripción o codificador por parte del analista.


```{r}
if (!require(GEOquery)) {
  BiocManager::install("GEOquery")
}
require(GEOquery)
gse <- getGEO("GSE35240")

```

```{r}
rawData <- gse[[1]]
rawData
```


El objeto `expressionSet`combina las difetrentes fuentes de información del estudio en una única estructura. Además de incluir toda la información generada durante el desarrollo del experimento, podemos cambiar la visualización de los datos para que sea más sencillo su uso.

```{r Cambio colnames rawData}
colnames(rawData) = c("D-Sas4_1", "D-Sas4_2", "D-Sas4_3", "D-Ssas6_1", "D-Ssas6_2", "D-Ssas6_3", "SakOE_1", "SakOE_2", "SakOE_3", "w67WT_1", "w67WT_2", "w67WT_3", "OregonRWT_1", "OregonRWT_2", "OregonRWT_3")
# rawData_2 <- cbind(rawData@assayData[["exprs"]])
```


##Control de calidad de los datos sin procesar

Se debe primero analizar si los datos tiene suficiente calidad para poder trabajar con ellos. Unos datos de mala calidad prodían producir demasiado ruido en el análisis que no será resuelto al realizar el proceso de normalización.


El primer para llevar esto a cabo será descargar el paquete `ArrayQualityMetrics` que nos permite desarrollar un estudio de calidad de los datos. Si resulta algún array fuera de los límites de calidad propuestos, aparecerá marcado con un asterisco y podrá ser detectado inmediatamente. Si el mismo array destaca tres veces, debería ser analizado y considerar su eliminación del estudio para mejorar cualitativamente el experimento.


```{r ControlCalidad, echo=TRUE}
arrayQualityMetrics(rawData, outdir="./results/rawdata_quality", force=TRUE)
```

Se realizará un análisis conjunto de la calidad de los datos y se creará una nueva carpeta con un informe llamado *index.html* en el que podremos acceder al resumen de los análisis desarrollados y que nos indicará las muestras de calidad dudosa mediante una marca en cada análisis y muestra en las que la calidad sea deficiente. En el objeto de nuestro estudio y como podemos ver en la figura \@ref(fig:dataset) no tenemos ninguna muestra cuya calidad deba preocuparnos. 

```{r}
#poner captura del informe
```

Desde este documento, se puede acceder a los gráficos de medición de la calidad de cada una de las muestras. A continuación desarrrollaremos algunas de ellas de manera global.

###Gráficos de densidad    

Mediante un histograma de densidad de Kernel, podemos hacernos una idea de las distribuciones de los distintos arrays del conjunto de datos. En la figura \@ref(fig:histrawData)Podemos apreciar que, probablemente debido al gran número de arrays, todos siguen el mismo patrón de distribución de la señal.

```{r histrawData, fig.cap="Histograma de los arrays del conjunto de datos."}
affy::hist(rawData)
```



###Diagramas de cajas

El diagrama de cajas también no mostrará la distribución de las intensidades, en la figura \@ref(fig:PCARaw) se pueden apreciar pequeñas variaciones esperables en los datos sin procesar.

```{r boxplotrawData, fig.cap="Diagramas de caja de la intensidad de los arrays para los datos sin procesar."}
tipos <- as.numeric(rawData$characteristics_ch1)
boxplot(rawData, las=2, cex.axis=0.5,
        col = c("orange", "green", "blue", "purple", "pink")[tipos],
        main="Distribución de intensidad")

```

###Análisis Componentes Principales

Mediante el análisis de componentes principales podemos detectar si las muestras se agrupan entre otras muestras del mismo grupo o si no hay una clara correspondencia entre ellas. Que las muestras no se agrupen por "familias" podría ser debido al efecto *batch* por defectos técnicos. 

Podemos realizar el análisis de componentes principales (ACP) de los datos, observando en el gráfico de la figura \@ref(fig:plot_rawData_ACP), la distribución de las dos primeras componentes de la expresión de cada gen (observaciones) sobre cada muestra (variables). Podemos ver como se distribuyen uniformemente a lo largo de la primera componente principal, salvo una perturbación que ocurre en valores altos de ambas componentes que habría que analizar.


```{r rawData_ACP}
#Para cada gen tenemos el perfil de expresión sobre todas las muestras.
rawData_ACP <- prcomp(rawData)
summary(rawData_ACP)
dim(rawData_ACP$rotation)
```




```{r plot_rawData_ACP, fig.cap="Dos primeras componentes principales de los datos sin procesar utilizando como variables la expresión en las muestras"}

plot(rawData_ACP$x[,1:2],
     col = c("orange", "green", "blue", "purple", "pink")[tipos],
     pch=16,
     xlab="CP1", ylab="CP2",
          main="ACP de las muestras")
abline(h=0,v=0, col="gray")
legend("topleft", pch = c(16,16,16,16,16),
       col=c("orange", "green", "blue", "purple","pink"),
       legend=c("D-Sas4", "D-Sas6", "OregonRWT", "SakOE", "w67WT"),
       cex=0.5)
```


Pero lo que nos interesa es considerar las diferentes muestras como observaciones, de forma que para cada muestra tenemos el perfil de expresión sobre todos los genes. De esta forma, podremos localizar rápidamente cuál es la principal fuente de variabilidad. 

```{r trawDAta_ACP, echo=TRUE}
#convertimos en matriz los datos para poder analizar los CP
#transponemos la matriz para indicar que las muestras son las observaciones
#y los genes las variables
trawData_ACP <-prcomp(t(as.matrix(rawData)), center = TRUE, scale=FALSE)
summary(trawData_ACP)
dim(trawData_ACP$rotation)
```

`
El gráfico de la figura \@ref(fig:plot_trawData_ACP) nos muestra las dos primeras componentes principales de la expresión sobre los genes de cada muestra. Se puede ver

```{r}
df_trawData_ACP <- as.data.frame(trawData_ACP$x)
```

```{r plot_trawData_ACP, fig.cap="Dos primeras componentes principales de los datos sin procesar utilizando como variables la expresión de los genes"}
labels=colnames(rawData)
#debemos convertir trawData_ACP a data frame
par(2,1)
ggplot(df_trawData_ACP, aes(PC1, PC2, label= labels)) +
  theme_classic()+
  geom_text_repel() +
  geom_vline(xintercept=0, color="gray")+
  geom_hline(yintercept = 0, color="gray")+
  geom_point(color=c("orange", "green", "blue", "purple", "pink")[tipos])

trawData_ACP2 <- prcomp(t(as.matrix(rawData[,-15])), center = TRUE, scale=FALSE)
summary(trawData_ACP2)
dim(trawData_ACP2$rotation)
plot(trawData_ACP2$x[,1], trawData_ACP2$x[,2], col = c("orange", "green", "blue", "purple", "pink")[tipos],
     pch=16,
     xlab="CP1", ylab="CP2",
     
     main="ACP de los genes")
abline(h=0,v=0, col="gray")
legend("bottomright", pch = c(16,16,16,16,16),
       col=c("orange", "green", "blue", "purple","pink"),
       legend=c("D-Sas4", "D-Sas6", "OregonRWT", "SakOE", "w67WT"),
       cex=0.5)
labels=colnames(rawData)
```



```{r plot_trawData_ACP2prueba, fig.cap="Dos primeras componentes principales de los datos sin procesar utilizando como variables la expresión de los genes"}
# trawData_ACP2 <- prcomp(t(as.matrix(rawData[,-15])), center = TRUE, scale=FALSE)
# summary(trawData_ACP2)
# dim(trawData_ACP2$rotation)
# plot(trawData_ACP2$x[,1], trawData_ACP2$x[,2], col = c("orange", "green", "blue", "purple", "pink")[tipos],
#      pch=16,
#      xlab="CP1", ylab="CP2",
#      
#      main="ACP de los genes")
# abline(h=0,v=0, col="gray")
# legend("bottomright", pch = c(16,16,16,16,16),
#        col=c("orange", "green", "blue", "purple","pink"),
#        legend=c("D-Sas4", "D-Sas6", "OregonRWT", "SakOE", "w67WT"),
#        cex=0.5)
# labels=colnames(rawData)
#text(trawData_ACP$x[,1], trawData_ACP$x[,2], labels, cex=0.5, pos=3,)
```


Se podría decir que eliminando la muestra discordante, los datos se agrupan mejor. Pero es muy raro que en un estudio se elimine un parámetro únicamente con una única prueba que indique algún tipo de problema. Antes de llegar a esos extremos, se siguen una serie de paso de análisis de los datos que sanearán el conjunto.

### Clúster Jerárquico

Otra forma de asegurarnos que las muestra se agrupan según los grupos experimentales, es mediante un clúster jerárquico que nos agrupa las muestras por grado de similaridad. Mediante un dendograma, se va mostrando a qué valor se produce l aunión de los grupos y qué grupos se unen.

Como podemos observar en la figura \@ref(fig:plot_trawData_ACP), la muestra OregonRWT3 vuelve a quedarse aislada de las otras dos réplicas.

```{r}
# rawDAta_cluster <- agnes(rawData, metric = "euclidean", method="average")
```

```{r}
rawData_cluster <- dist(t(as.matrix(rawData)), method="euclidian")
rawData_cluster1 <- hclust(rawData_cluster, method="single")
```

```{r}
ggdendrogram(rawData_cluster1, rotate=FALSE, size=2)
```
```{r}

```

### Gráfico M-A

### Gráficos de degradación

### Modelos de bajo nivel

##Normalización
# Bibliografía

https://www.uv.es/ayala/docencia/tami/tami13.pdf

